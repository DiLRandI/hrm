package auth

import (
  "errors"
  "time"

  "github.com/golang-jwt/jwt/v5"
  "golang.org/x/crypto/bcrypt"
)

type Claims struct {
  UserID   string `json:"uid"`
  TenantID string `json:"tid"`
  RoleID   string `json:"rid"`
  RoleName string `json:"role"`
  jwt.RegisteredClaims
}

func HashPassword(password string) (string, error) {
  hashed, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
  if err != nil {
    return "", err
  }
  return string(hashed), nil
}

func CheckPassword(hash, password string) error {
  return bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
}

func GenerateToken(secret string, claims Claims, ttl time.Duration) (string, error) {
  claims.RegisteredClaims = jwt.RegisteredClaims{
    ExpiresAt: jwt.NewNumericDate(time.Now().Add(ttl)),
    IssuedAt:  jwt.NewNumericDate(time.Now()),
  }
  token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
  return token.SignedString([]byte(secret))
}

func ParseToken(secret, tokenString string) (*Claims, error) {
  token, err := jwt.ParseWithClaims(tokenString, &Claims{}, func(token *jwt.Token) (interface{}, error) {
    if token.Method != jwt.SigningMethodHS256 {
      return nil, errors.New("unexpected signing method")
    }
    return []byte(secret), nil
  })
  if err != nil {
    return nil, err
  }
  claims, ok := token.Claims.(*Claims)
  if !ok || !token.Valid {
    return nil, errors.New("invalid token")
  }
  return claims, nil
}
